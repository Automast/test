api.ts
// productlib/api.ts
import { IApiResponse, IProduct } from './types';

// Always use the full backend URL from NEXT_PUBLIC_API_URL (or default to localhost:5000/api)
const API_BASE_URL =
  (process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5000/api')
    .replace(/\/$/, '');  // trim trailing slash if any

export const getApiUrl = (path: string): string => {
  // Ensure path starts with a single '/'
  const normalizedPath = path.startsWith('/') ? path : `/${path}`;
  return `${API_BASE_URL}${normalizedPath}`;
};

/**
 * Fetch a product by slug
 */
export const getProductBySlug = async (slug: string): Promise<IProduct | null> => {
  try {
    if (!slug) {
      console.error('Invalid slug provided to getProductBySlug');
      return null;
    }
    
    // Ensure slug is properly encoded for URLs
    const encodedSlug = encodeURIComponent(slug);
    const url = getApiUrl(`/products/public/${encodedSlug}`);
    
    console.log(`Fetching product with slug: ${encodedSlug} from URL: ${url}`);
    
    // Use Next.js fetch with only one caching strategy
    const response = await fetch(url, { 
      // Using only next.revalidate instead of both no-store and revalidate
      next: { revalidate: 60 }
    });
    
    // Try to get more information about the error
    if (!response.ok) {
      if (response.status === 404) {
        console.log(`Product not found for slug: ${slug}`);
        return null; // Product not found
      }
      
      // For 500 errors, try to get more details from the response
      if (response.status === 500) {
        try {
          // Try to parse the error response
          const errorData = await response.json();
          console.error('Server error details:', errorData);
          
          // Return null instead of throwing to avoid breaking the page
          console.error(`Server error (500) for slug ${slug}: ${JSON.stringify(errorData)}`);
          return null;
        } catch (parseError) {
          console.error('Could not parse error response:', parseError);
          // Return null instead of throwing
          return null;
        }
      }
      
      // For other errors, log but don't throw
      console.error(`Error fetching product (${response.status}): ${response.statusText}`);
      return null;
    }
    
    const data = await response.json();
    
    if (!data.success || !data.data?.product) {
      console.log(`API returned success: ${data.success}, but no product data`);
      return null;
    }
    
    console.log(`Successfully fetched product: ${data.data.product.title}`);
    return data.data.product;
  } catch (error) {
    console.error('Error fetching product:', error);
    // Instead of re-throwing, return null to fail gracefully
    return null;
  }
};

/**
 * Create a new transaction - format data to match backend API expectations
 */
export const createTransaction = async (transactionData: any): Promise<IApiResponse<any>> => {
  try {
    const url = getApiUrl('/finance/transactions');
    
    // Log transaction data for debugging (omitting sensitive info)
    console.log('Creating transaction:', {
      ...transactionData,
      buyerEmail: transactionData.buyerEmail ? '***@***.com' : undefined,
    });
    
    // No authentication token required for public payments
    const headers: Record<string, string> = {
      'Content-Type': 'application/json'
    };

    const response = await fetch(url, {
      method: 'POST',
      headers,
      body: JSON.stringify(transactionData),
    });
    
    // Log response status for debugging
    console.log('Transaction API response status:', response.status);
    
    // Better error handling for non-2xx responses
    if (!response.ok) {
      let errorDetails = 'Unknown error';
      try {
        const errorData = await response.json();
        errorDetails = errorData.message || 'Failed to create transaction';
        console.error('Error details:', errorData);
      } catch (parseError) {
        console.error('Could not parse error response:', parseError);
      }
      throw new Error(errorDetails);
    }

    const data: IApiResponse<any> = await response.json();
    return data;
  } catch (error) {
    console.error('Error creating transaction:', error);
    throw error;
  }
};

/**
 * Get IP Address (using a public API)
 */
export const getIPAddress = async (): Promise<string> => {
  try {
    const response = await fetch('https://api.ipify.org?format=json');
    const data = await response.json();
    return data.ip;
  } catch (error) {
    console.error('Error getting IP address:', error);
    return '';
  }
};

/**
 * Get device and browser information
 */
export const getDeviceInfo = (): { deviceInfo: string; browserInfo: string } => {
  const userAgent = navigator.userAgent;
  
  let deviceInfo = 'Unknown Device';
  let browserInfo = 'Unknown Browser';
  
  // Simple device detection
  if (/Android/i.test(userAgent)) {
    const match = userAgent.match(/Android\s([0-9.]+)/);
    deviceInfo = `Mobile (Android ${match ? match[1] : ''})`;
  } else if (/iPhone|iPad|iPod/i.test(userAgent)) {
    const match = userAgent.match(/OS\s([0-9_]+)/);
    const version = match ? match[1].replace(/_/g, '.') : '';
    deviceInfo = `Mobile (iOS ${version})`;
  } else if (/Windows/i.test(userAgent)) {
    const match = userAgent.match(/Windows NT\s([0-9.]+)/);
    deviceInfo = `Desktop (Windows ${match ? match[1] : ''})`;
  } else if (/Mac OS X/i.test(userAgent)) {
    const match = userAgent.match(/Mac OS X\s([0-9_.]+)/);
    const version = match ? match[1].replace(/_/g, '.') : '';
    deviceInfo = `Desktop (macOS ${version})`;
  } else if (/Linux/i.test(userAgent)) {
    deviceInfo = 'Desktop (Linux)';
  }
  
  // Simple browser detection
  if (/Chrome/i.test(userAgent) && !/Chromium|Edge/i.test(userAgent)) {
    const match = userAgent.match(/Chrome\/([0-9.]+)/);
    browserInfo = `Chrome ${match ? match[1] : ''}`;
  } else if (/Firefox/i.test(userAgent)) {
    const match = userAgent.match(/Firefox\/([0-9.]+)/);
    browserInfo = `Firefox ${match ? match[1] : ''}`;
  } else if (/Safari/i.test(userAgent) && !/Chrome|Chromium/i.test(userAgent)) {
    const match = userAgent.match(/Safari\/([0-9.]+)/);
    browserInfo = `Safari ${match ? match[1] : ''}`;
  } else if (/Edge/i.test(userAgent)) {
    const match = userAgent.match(/Edge\/([0-9.]+)/);
    browserInfo = `Edge ${match ? match[1] : ''}`;
  } else if (/MSIE|Trident/i.test(userAgent)) {
    const match = userAgent.match(/(?:MSIE |rv:)([0-9.]+)/);
    browserInfo = `Internet Explorer ${match ? match[1] : ''}`;
  }
  
  return { deviceInfo, browserInfo };
};

currency.ts
// productlib/currency.ts
import { ICurrency } from './types';

// Define currencies with their properties
export const currencies: Record<string, ICurrency> = {
    USD: { code: 'USD', symbol: '$',  name: 'US Dollar',                   countries: ['US','EC','SV','PA','TL','PW','FM','MH','ZW'],                       pixSupported: false },
    EUR: { code: 'EUR', symbol: '€',  name: 'Euro',                        countries: ['DE','FR','IT','ES','PT','NL','BE','AT','GR','IE','FI','SK','SI','LT','LV','EE','CY','MT','LU','HR'], pixSupported: false },
    GBP: { code: 'GBP', symbol: '£',  name: 'British Pound',               countries: ['GB'],                                                              pixSupported: false },
    CAD: { code: 'CAD', symbol: 'C$', name: 'Canadian Dollar',             countries: ['CA'],                                                             pixSupported: false },
    AUD: { code: 'AUD', symbol: 'A$', name: 'Australian Dollar',           countries: ['AU'],                                                             pixSupported: false },
    NZD: { code: 'NZD', symbol: 'NZ$',name: 'New Zealand Dollar',          countries: ['NZ','CK','NU','PN','TK'],                                         pixSupported: false },
    JPY: { code: 'JPY', symbol: '¥',  name: 'Japanese Yen',                countries: ['JP'],                                                             pixSupported: false },
    CNY: { code: 'CNY', symbol: '¥',  name: 'Chinese Yuan',                countries: ['CN'],                                                             pixSupported: false },
    HKD: { code: 'HKD', symbol: 'HK$',name: 'Hong Kong Dollar',            countries: ['HK'],                                                             pixSupported: false },
    SGD: { code: 'SGD', symbol: 'S$', name: 'Singapore Dollar',            countries: ['SG'],                                                             pixSupported: false },
    INR: { code: 'INR', symbol: '₹',  name: 'Indian Rupee',                countries: ['IN'],                                                             pixSupported: false },
    PKR: { code: 'PKR', symbol: '₨',  name: 'Pakistani Rupee',             countries: ['PK'],                                                             pixSupported: false },
    BDT: { code: 'BDT', symbol: '৳',  name: 'Bangladeshi Taka',            countries: ['BD'],                                                             pixSupported: false },
    IDR: { code: 'IDR', symbol: 'Rp', name: 'Indonesian Rupiah',           countries: ['ID'],                                                             pixSupported: false },
    MYR: { code: 'MYR', symbol: 'RM', name: 'Malaysian Ringgit',           countries: ['MY'],                                                             pixSupported: false },
    THB: { code: 'THB', symbol: '฿',  name: 'Thai Baht',                   countries: ['TH'],                                                             pixSupported: false },
    VND: { code: 'VND', symbol: '₫',  name: 'Vietnamese Đồng',             countries: ['VN'],                                                             pixSupported: false },
    PHP: { code: 'PHP', symbol: '₱',  name: 'Philippine Peso',             countries: ['PH'],                                                             pixSupported: false },
    KRW: { code: 'KRW', symbol: '₩',  name: 'South Korean Won',            countries: ['KR'],                                                             pixSupported: false },
    TWD: { code: 'TWD', symbol: 'NT$',name: 'New Taiwan Dollar',           countries: ['TW'],                                                             pixSupported: false },
    SAR: { code: 'SAR', symbol: '﷼',  name: 'Saudi Riyal',                 countries: ['SA'],                                                             pixSupported: false },
    AED: { code: 'AED', symbol: 'د.إ',name: 'UAE Dirham',                  countries: ['AE'],                                                             pixSupported: false },
    QAR: { code: 'QAR', symbol: '﷼',  name: 'Qatari Riyal',                countries: ['QA'],                                                             pixSupported: false },
    KWD: { code: 'KWD', symbol: 'د.ك',name: 'Kuwaiti Dinar',               countries: ['KW'],                                                             pixSupported: false },
    BHD: { code: 'BHD', symbol: 'ب.د',name: 'Bahraini Dinar',              countries: ['BH'],                                                             pixSupported: false },
    OMR: { code: 'OMR', symbol: '﷼',  name: 'Omani Rial',                  countries: ['OM'],                                                             pixSupported: false },
    JOD: { code: 'JOD', symbol: 'د.ا',name: 'Jordanian Dinar',             countries: ['JO'],                                                             pixSupported: false },
    EGP: { code: 'EGP', symbol: '£',  name: 'Egyptian Pound',              countries: ['EG'],                                                             pixSupported: false },
    MAD: { code: 'MAD', symbol: 'د.م.',name: 'Moroccan Dirham',            countries: ['MA'],                                                             pixSupported: false },
    DZD: { code: 'DZD', symbol: 'دج', name: 'Algerian Dinar',              countries: ['DZ'],                                                             pixSupported: false },
    TND: { code: 'TND', symbol: 'د.ت',name: 'Tunisian Dinar',              countries: ['TN'],                                                             pixSupported: false },
    NGN: { code: 'NGN', symbol: '₦',  name: 'Nigerian Naira',              countries: ['NG'],                                                             pixSupported: false },
    GHS: { code: 'GHS', symbol: '₵',  name: 'Ghanaian Cedi',               countries: ['GH'],                                                             pixSupported: false },
    KES: { code: 'KES', symbol: 'KSh',name: 'Kenyan Shilling',             countries: ['KE'],                                                             pixSupported: false },
    TZS: { code: 'TZS', symbol: 'TSh',name: 'Tanzanian Shilling',          countries: ['TZ'],                                                             pixSupported: false },
    ZAR: { code: 'ZAR', symbol: 'R',  name: 'South African Rand',          countries: ['ZA','LS','SZ','NA'],                                              pixSupported: false },
    XOF: { code: 'XOF', symbol: 'CFA',name: 'West African CFA Franc',      countries: ['BJ','BF','CI','GW','ML','NE','SN','TG'],                           pixSupported: false },
    XAF: { code: 'XAF', symbol: 'CFA',name: 'Central African CFA Franc',   countries: ['CM','CF','TD','CG','GQ','GA'],                                     pixSupported: false },
    XPF: { code: 'XPF', symbol: '₣',  name: 'CFP Franc',                   countries: ['PF','NC','WF'],                                                   pixSupported: false },
    GYD: { code: 'GYD', symbol: 'G$', name: 'Guyanese Dollar',             countries: ['GY'],                                                             pixSupported: false },
    ARS: { code: 'ARS', symbol: 'AR$',name: 'Argentine Peso',              countries: ['AR'],                                                             pixSupported: false },
    CLP: { code: 'CLP', symbol: 'CLP$',name: 'Chilean Peso',               countries: ['CL'],                                                             pixSupported: false },
    COP: { code: 'COP', symbol: 'COL$',name: 'Colombian Peso',             countries: ['CO'],                                                             pixSupported: false },
    PEN: { code: 'PEN', symbol: 'S/', name: 'Peruvian Sol',                countries: ['PE'],                                                             pixSupported: false },
    UYU: { code: 'UYU', symbol: '$U', name: 'Uruguayan Peso',              countries: ['UY'],                                                             pixSupported: false },
    PYG: { code: 'PYG', symbol: '₲',  name: 'Paraguayan Guarani',          countries: ['PY'],                                                             pixSupported: false },
    BOB: { code: 'BOB', symbol: 'Bs.',name: 'Bolivian Boliviano',          countries: ['BO'],                                                             pixSupported: false },
    BRL: { code: 'BRL', symbol: 'R$', name: 'Brazilian Real',              countries: ['BR'],                                                             pixSupported: true  },
    MXN: { code: 'MXN', symbol: 'MX$',name: 'Mexican Peso',                countries: ['MX'],                                                             pixSupported: false },
    CRC: { code: 'CRC', symbol: '₡',  name: 'Costa Rican Colón',           countries: ['CR'],                                                             pixSupported: false },
    DOP: { code: 'DOP', symbol: 'RD$',name: 'Dominican Peso',              countries: ['DO'],                                                             pixSupported: false },
    HNL: { code: 'HNL', symbol: 'L',  name: 'Honduran Lempira',            countries: ['HN'],                                                             pixSupported: false },
    GTQ: { code: 'GTQ', symbol: 'Q',  name: 'Guatemalan Quetzal',          countries: ['GT'],                                                             pixSupported: false },
    NIO: { code: 'NIO', symbol: 'C$', name: 'Nicaraguan Córdoba',          countries: ['NI'],                                                             pixSupported: false },
    BZD: { code: 'BZD', symbol: 'BZ$',name: 'Belize Dollar',               countries: ['BZ'],                                                             pixSupported: false },
    HTG: { code: 'HTG', symbol: 'G',  name: 'Haitian Gourde',              countries: ['HT'],                                                             pixSupported: false },
    BSD: { code: 'BSD', symbol: 'B$', name: 'Bahamian Dollar',             countries: ['BS'],                                                             pixSupported: false },
    KYD: { code: 'KYD', symbol: 'CI$',name: 'Cayman Islands Dollar',       countries: ['KY'],                                                             pixSupported: false },
    BMD: { code: 'BMD', symbol: 'BD$',name: 'Bermudian Dollar',            countries: ['BM'],                                                             pixSupported: false },
    TTD: { code: 'TTD', symbol: 'TT$',name: 'Trinidad and Tobago Dollar',  countries: ['TT'],                                                             pixSupported: false },
    XCD: { code: 'XCD', symbol: 'EC$',name: 'East Caribbean Dollar',       countries: ['AG','DM','GD','KN','LC','VC','AI','MS'],                           pixSupported: false },
    CHF: { code: 'CHF', symbol: 'Fr', name: 'Swiss Franc',                 countries: ['CH','LI'],                                                        pixSupported: false },
    SEK: { code: 'SEK', symbol: 'kr', name: 'Swedish Krona',               countries: ['SE'],                                                             pixSupported: false },
    NOK: { code: 'NOK', symbol: 'kr', name: 'Norwegian Krone',             countries: ['NO','SJ'],                                                        pixSupported: false },
    DKK: { code: 'DKK', symbol: 'kr', name: 'Danish Krone',                countries: ['DK','GL','FO'],                                                   pixSupported: false },
    PLN: { code: 'PLN', symbol: 'zł', name: 'Polish Złoty',                countries: ['PL'],                                                             pixSupported: false },
    CZK: { code: 'CZK', symbol: 'Kč', name: 'Czech Koruna',                countries: ['CZ'],                                                             pixSupported: false },
    HUF: { code: 'HUF', symbol: 'Ft', name: 'Hungarian Forint',            countries: ['HU'],                                                             pixSupported: false },
    RON: { code: 'RON', symbol: 'lei',name: 'Romanian Leu',                countries: ['RO'],                                                             pixSupported: false },
    BGN: { code: 'BGN', symbol: 'лв', name: 'Bulgarian Lev',               countries: ['BG'],                                                             pixSupported: false },
    RSD: { code: 'RSD', symbol: 'дин',name: 'Serbian Dinar',               countries: ['RS'],                                                             pixSupported: false },
    RUB: { code: 'RUB', symbol: '₽',  name: 'Russian Ruble',               countries: ['RU'],                                                             pixSupported: false },
    TRY: { code: 'TRY', symbol: '₺',  name: 'Turkish Lira',                countries: ['TR','CY'],                                                        pixSupported: false },
    UAH: { code: 'UAH', symbol: '₴',  name: 'Ukrainian Hryvnia',           countries: ['UA'],                                                             pixSupported: false },
    BYN: { code: 'BYN', symbol: 'Br', name: 'Belarusian Ruble',            countries: ['BY'],                                                             pixSupported: false },
    KZT: { code: 'KZT', symbol: '₸',  name: 'Kazakhstani Tenge',           countries: ['KZ'],                                                             pixSupported: false },
    UZS: { code: 'UZS', symbol: "so'm",name: 'Uzbekistani Soʻm',           countries: ['UZ'],                                                             pixSupported: false },
    AZN: { code: 'AZN', symbol: '₼',  name: 'Azerbaijani Manat',           countries: ['AZ'],                                                             pixSupported: false },
    GEL: { code: 'GEL', symbol: '₾',  name: 'Georgian Lari',               countries: ['GE'],                                                             pixSupported: false },
    AMD: { code: 'AMD', symbol: '֏',  name: 'Armenian Dram',               countries: ['AM'],                                                             pixSupported: false },
    IRR: { code: 'IRR', symbol: '﷼',  name: 'Iranian Rial',                countries: ['IR'],                                                             pixSupported: false },
    IQD: { code: 'IQD', symbol: 'ع.د',name: 'Iraqi Dinar',                 countries: ['IQ'],                                                             pixSupported: false },
    LBP: { code: 'LBP', symbol: 'ل.ل',name: 'Lebanese Pound',              countries: ['LB'],                                                             pixSupported: false },
    SYP: { code: 'SYP', symbol: '£',  name: 'Syrian Pound',                countries: ['SY'],                                                             pixSupported: false },
    YER: { code: 'YER', symbol: '﷼',  name: 'Yemeni Rial',                 countries: ['YE'],                                                             pixSupported: false },
    AFN: { code: 'AFN', symbol: '؋',  name: 'Afghan Afghani',              countries: ['AF'],                                                             pixSupported: false },
    NPR: { code: 'NPR', symbol: '₨',  name: 'Nepalese Rupee',              countries: ['NP'],                                                             pixSupported: false },
    BTN: { code: 'BTN', symbol: 'Nu.',name: 'Bhutanese Ngultrum',          countries: ['BT'],                                                             pixSupported: false },
    LKR: { code: 'LKR', symbol: 'Rs', name: 'Sri Lankan Rupee',            countries: ['LK'],                                                             pixSupported: false },
    MMK: { code: 'MMK', symbol: 'K',  name: 'Myanmar Kyat',                countries: ['MM'],                                                             pixSupported: false },
    KHR: { code: 'KHR', symbol: '៛',  name: 'Cambodian Riel',              countries: ['KH'],                                                             pixSupported: false },
    LAK: { code: 'LAK', symbol: '₭',  name: 'Lao Kip',                     countries: ['LA'],                                                             pixSupported: false },
    MNT: { code: 'MNT', symbol: '₮',  name: 'Mongolian Tögrög',            countries: ['MN'],                                                             pixSupported: false },
    PGK: { code: 'PGK', symbol: 'K',  name: 'Papua New Guinean Kina',      countries: ['PG'],                                                             pixSupported: false },
    SBD: { code: 'SBD', symbol: 'SI$',name: 'Solomon Islands Dollar',      countries: ['SB'],                                                             pixSupported: false },
    VUV: { code: 'VUV', symbol: 'VT', name: 'Vanuatu Vatu',                countries: ['VU'],                                                             pixSupported: false },
    WST: { code: 'WST', symbol: 'WS$',name: 'Samoan Tala',                 countries: ['WS'],                                                             pixSupported: false },
    TOP: { code: 'TOP', symbol: 'T$', name: "Tongan Pa'anga",              countries: ['TO'],                                                             pixSupported: false },
    FJD: { code: 'FJD', symbol: 'FJ$',name: 'Fijian Dollar',               countries: ['FJ'],                                                             pixSupported: false },
    MGA: { code: 'MGA', symbol: 'Ar', name: 'Malagasy Ariary',             countries: ['MG'],                                                             pixSupported: false },
    MUR: { code: 'MUR', symbol: 'Rs', name: 'Mauritian Rupee',             countries: ['MU'],                                                             pixSupported: false },
    SCR: { code: 'SCR', symbol: 'Rs', name: 'Seychellois Rupee',           countries: ['SC'],                                                             pixSupported: false },
    MZN: { code: 'MZN', symbol: 'MT', name: 'Mozambican Metical',          countries: ['MZ'],                                                             pixSupported: false },
    ZMW: { code: 'ZMW', symbol: 'ZK', name: 'Zambian Kwacha',              countries: ['ZM'],                                                             pixSupported: false },
    MWK: { code: 'MWK', symbol: 'MK', name: 'Malawian Kwacha',             countries: ['MW'],                                                             pixSupported: false },
    GNF: { code: 'GNF', symbol: 'FG', name: 'Guinean Franc',               countries: ['GN'],                                                             pixSupported: false },
    RWF: { code: 'RWF', symbol: 'RF', name: 'Rwandan Franc',               countries: ['RW'],                                                             pixSupported: false },
    BIF: { code: 'BIF', symbol: 'FBu',name: 'Burundian Franc',             countries: ['BI'],                                                             pixSupported: false },
    UGX: { code: 'UGX', symbol: 'USh',name: 'Ugandan Shilling',            countries: ['UG'],                                                             pixSupported: false },
    SSP: { code: 'SSP', symbol: '£',  name: 'South Sudanese Pound',        countries: ['SS'],                                                             pixSupported: false },
    SDG: { code: 'SDG', symbol: '£',  name: 'Sudanese Pound',              countries: ['SD'],                                                             pixSupported: false },
    MOP: { code: 'MOP', symbol: 'MOP$',name: 'Macanese Pataca',            countries: ['MO'],                                                             pixSupported: false },
    CUP: { code: 'CUP', symbol: '₱',  name: 'Cuban Peso',                  countries: ['CU'],                                                             pixSupported: false },
    BWP: { code: 'BWP', symbol: 'P',  name: 'Botswanan Pula',              countries: ['BW'],                                                             pixSupported: false },
    NAD: { code: 'NAD', symbol: 'N$', name: 'Namibian Dollar',             countries: ['NA'],                                                             pixSupported: false },
    ETB: { code: 'ETB', symbol: 'Br', name: 'Ethiopian Birr',              countries: ['ET'],                                                             pixSupported: false },
    KPW: { code: 'KPW', symbol: '₩',  name: 'North Korean Won',            countries: ['KP'],                                                             pixSupported: false },
    SLE: { code: 'SLE', symbol: 'Le', name: 'Sierra Leonean Leone',        countries: ['SL'],                                                             pixSupported: false },
    GMD: { code: 'GMD', symbol: 'D',  name: 'Gambian Dalasi',              countries: ['GM'],                                                             pixSupported: false },
    CVE: { code: 'CVE', symbol: '$',  name: 'Cape Verdean Escudo',         countries: ['CV'],                                                             pixSupported: false },
    DJF: { code: 'DJF', symbol: 'Fdj',name: 'Djiboutian Franc',            countries: ['DJ'],                                                             pixSupported: false },
    ERN: { code: 'ERN', symbol: 'Nfk',name: 'Eritrean Nakfa',              countries: ['ER'],                                                             pixSupported: false },
    KMF: { code: 'KMF', symbol: 'CF', name: 'Comorian Franc',             countries: ['KM'],                                                             pixSupported: false },
    TMT: { code: 'TMT', symbol: 'm',  name: 'Turkmenistani Manat',         countries: ['TM'],                                                             pixSupported: false },
    TJS: { code: 'TJS', symbol: 'ЅM', name: 'Tajikistani Somoni',          countries: ['TJ'],                                                             pixSupported: false },
    MRU: { code: 'MRU', symbol: 'UM', name: 'Mauritanian Ouguiya',         countries: ['MR'],                                                             pixSupported: false },
    STN: { code: 'STN', symbol: 'Db', name: 'São Tomé and Príncipe Dobra', countries: ['ST'],                                                             pixSupported: false },
    PAB: { code: 'PAB', symbol: 'B/.',name: 'Panamanian Balboa',           countries: ['PA'],                                                             pixSupported: false },
};

// Free Exchange Rate API
const EXCHANGE_RATE_API = 'https://open.er-api.com/v6/latest/';

/**
 * Get the currency for a country code
 */
export const getCurrencyForCountry = (countryCode: string): string => {
  for (const [code, currency] of Object.entries(currencies)) {
    if (currency.countries.includes(countryCode)) {
      return code;
    }
  }
  return 'USD'; // Default to USD if not found
};

/**
 * Format price with currency symbol
 */
export const formatPrice = (price: number, currencyCode: string): string => {
  const currency = currencies[currencyCode] || currencies.USD;
  
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: currencyCode,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  }).format(price);
};

// Fallback rates for common currency pairs (as of May 2025)
const fallbackRates: Record<string, Record<string, number>> = {
  USD: { 
    BRL: 5.88, 
    EUR: 0.93, 
    GBP: 0.79, 
    CAD: 1.36, 
    AUD: 1.51, 
    JPY: 154.32,
    NGN: 1465.00, // Nigerian Naira
    GHS: 15.75,  // Ghanaian Cedi
    KES: 130.50, // Kenyan Shilling
    ZAR: 18.25,  // South African Rand
    INR: 83.95,  // Indian Rupee
    PHP: 57.20,  // Philippine Peso
    MXN: 16.80,  // Mexican Peso
  },
  // Add inverse rates for common conversions back to USD
  BRL: { USD: 0.17 },
  EUR: { USD: 1.08 },
  GBP: { USD: 1.27 },
  NGN: { USD: 0.00068 },
};

/**
 * Convert price from one currency to another
 */
export const convertPrice = async (
  price: number, 
  fromCurrency: string, 
  toCurrency: string
): Promise<number> => {
  // If same currency, no conversion needed
  if (fromCurrency === toCurrency) {
    return price;
  }
  
  try {
    console.log(`Converting ${price} from ${fromCurrency} to ${toCurrency}`);
    const response = await fetch(`${EXCHANGE_RATE_API}${fromCurrency}`);
    const data = await response.json();
    
    if (data.rates && data.rates[toCurrency]) {
      const convertedPrice = price * data.rates[toCurrency];
      console.log(`Converted to ${convertedPrice} ${toCurrency} using API rate ${data.rates[toCurrency]}`);
      return parseFloat(convertedPrice.toFixed(2));
    }
    
    throw new Error(`Exchange rate not found for ${fromCurrency} to ${toCurrency}`);
  } catch (error) {
    console.error('Currency conversion error:', error);
    
    // Try direct conversion using fallback rates
    if (fallbackRates[fromCurrency]?.[toCurrency]) {
      const convertedPrice = price * fallbackRates[fromCurrency][toCurrency];
      console.log(`Converted to ${convertedPrice} ${toCurrency} using fallback rate ${fallbackRates[fromCurrency][toCurrency]}`);
      return parseFloat(convertedPrice.toFixed(2));
    }
    
    // Try indirect conversion through USD
    if (fromCurrency !== 'USD' && toCurrency !== 'USD') {
      try {
        // Convert from source currency to USD
        let usdAmount = price;
        if (fallbackRates[fromCurrency]?.USD) {
          usdAmount = price * fallbackRates[fromCurrency].USD;
        } else if (fallbackRates.USD?.[fromCurrency]) {
          usdAmount = price / fallbackRates.USD[fromCurrency];
        }
        
        // Convert from USD to target currency
        if (fallbackRates.USD?.[toCurrency]) {
          const convertedPrice = usdAmount * fallbackRates.USD[toCurrency];
          console.log(`Converted to ${convertedPrice} ${toCurrency} via USD using fallback rates`);
          return parseFloat(convertedPrice.toFixed(2));
        }
      } catch (indirectError) {
        console.error('Indirect conversion error:', indirectError);
      }
    }
    
    // Default to original price if conversion fails
    console.warn(`Falling back to original price due to conversion failure`);
    return price;
  }
};

/**
 * Convert all price components using the same conversion rate
 */
export const convertPriceComponents = (
  unitPrice: number,
  convertedUnitPrice: number,
  components: { subtotal: number; vat: number; shipping: number; total: number }
): { subtotal: number; vat: number; shipping: number; total: number } => {
  // Calculate the conversion rate based on the unit price conversion
  const conversionRate = convertedUnitPrice / unitPrice;
  
  // Convert each component using the same rate
  return {
    subtotal: parseFloat((components.subtotal * conversionRate).toFixed(2)),
    vat: parseFloat((components.vat * conversionRate).toFixed(2)),
    shipping: parseFloat((components.shipping * conversionRate).toFixed(2)),
    total: parseFloat(((components.subtotal + components.vat + components.shipping) * conversionRate).toFixed(2))
  };
};

/**
 * Check if PIX payment is supported for a currency
 */
export const isPixSupported = (currencyCode: string): boolean => {
  return currencies[currencyCode]?.pixSupported || false;
};

/**
 * Get user country from IP (simplified version - would use a real geolocation API)
 */
/**
 * Get user country using multiple free APIs for better accuracy
 */
export const getUserCountry = async (): Promise<string> => {
  const apis = [
    {
      name: 'api.country.is',
      url: 'https://api.country.is',
      parseResponse: (data: any) => data.country
    },
    {
      name: 'ipapi.co',
      url: 'https://ipapi.co/json/',
      parseResponse: (data: any) => data.country_code
    },
    {
      name: 'ip-api.com',
      url: 'http://ip-api.com/json/',
      parseResponse: (data: any) => data.countryCode
    },
    {
      name: 'ipinfo.io',
      url: 'https://ipinfo.io/json',
      parseResponse: (data: any) => data.country
    },
    {
      name: 'ipgeolocation.io',
      url: 'https://api.ipgeolocation.io/ipgeo?apiKey=',
      parseResponse: (data: any) => data.country_code2
    },
    {
      name: 'geoplugin.net',
      url: 'http://www.geoplugin.net/json.gp',
      parseResponse: (data: any) => data.geoplugin_countryCode
    },
    {
      name: 'db-ip.com',
      url: 'https://api.db-ip.com/v2/free/self',
      parseResponse: (data: any) => data.countryCode
    }
  ];

  const results: string[] = [];
  const timeout = 3000; // 3 seconds timeout for each API

  console.log('[Country Detection] Starting country detection with', apis.length, 'APIs');

  // Create promises for all API calls
  const apiPromises = apis.map(async (api) => {
    try {
      console.log(`[Country Detection] Trying ${api.name}...`);
      
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);
      
      const response = await fetch(api.url, {
        signal: controller.signal,
        headers: {
          'Accept': 'application/json',
          'User-Agent': 'Mozilla/5.0 (compatible; CountryDetection/1.0)'
        }
      });
      
      clearTimeout(timeoutId);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      
      const data = await response.json();
      const country = api.parseResponse(data);
      
      if (country && typeof country === 'string' && country.length === 2) {
        console.log(`[Country Detection] ${api.name} returned: ${country}`);
        return country.toUpperCase();
      } else {
        console.warn(`[Country Detection] ${api.name} returned invalid country:`, country);
        return null;
      }
    } catch (error) {
      console.warn(`[Country Detection] ${api.name} failed:`, error instanceof Error ? error.message : error);
      return null;
    }
  });

  // Wait for all promises to complete (or timeout)
  try {
    const apiResults = await Promise.allSettled(apiPromises);
    
    // Collect successful results
    apiResults.forEach((result) => {
      if (result.status === 'fulfilled' && result.value) {
        results.push(result.value);
      }
    });
    
    console.log('[Country Detection] All API results:', results);
    
    if (results.length === 0) {
      console.warn('[Country Detection] No APIs returned valid results, defaulting to US');
      return 'US';
    }
    
    // Count occurrences of each country
    const countryCounts: Record<string, number> = {};
    results.forEach(country => {
      countryCounts[country] = (countryCounts[country] || 0) + 1;
    });
    
    console.log('[Country Detection] Country vote counts:', countryCounts);
    
    // Find the country with the highest count
    let winningCountry = 'US';
    let maxCount = 0;
    
    for (const [country, count] of Object.entries(countryCounts)) {
      if (count > maxCount) {
        maxCount = count;
        winningCountry = country;
      }
    }
    
    // Require at least 2 APIs to agree, otherwise default to US
    if (maxCount < 2 && results.length >= 2) {
      console.warn('[Country Detection] No consensus reached (max count:', maxCount, '), defaulting to US');
      return 'US';
    }
    
    console.log(`[Country Detection] Final decision: ${winningCountry} (${maxCount}/${results.length} votes)`);
    return winningCountry;
    
  } catch (error) {
    console.error('[Country Detection] Error in country detection process:', error);
    return 'US';
  }
};

/**
 * Get user currency based on their location
 */
export const getUserCurrency = async (): Promise<string> => {
  const country = await getUserCountry();
  const currency = getCurrencyForCountry(country);
  console.log(`User currency for country ${country}: ${currency}`);
  return currency;
};

logger.ts
// productlib/logger.ts
const isBrowser = typeof window !== 'undefined';

const logger = {
  info: (...args: any[]) => {
    if (isBrowser || process.env.NODE_ENV === 'development') {
      console.log('[FE_INFO]', ...args);
    }
  },
  warn: (...args: any[]) => {
    if (isBrowser || process.env.NODE_ENV === 'development') {
      console.warn('[FE_WARN]', ...args);
    }
  },
  error: (...args: any[]) => {
    if (isBrowser || process.env.NODE_ENV === 'development') {
      console.error('[FE_ERROR]', ...args);
    }
  },
};

export default logger;

tax.ts
// productlib/tax.ts
interface TaxRate {
  type: string;
  currency: string;
  rate: number;
  states?: Record<string, {
    rate: number;
    type: string;
  }>;
  before?: Record<string, {
    type: string;
    currency: string;
    rate: number;
  }>;
}

interface TaxData {
  [countryCode: string]: TaxRate;
}

let taxData: TaxData | null = null;

/**
 * Load tax data from tax.json file
 */
const loadTaxData = async (): Promise<TaxData> => {
  if (taxData) {
    return taxData;
  }

  try {
    console.log('[Tax] Loading tax data from /tax.json');
    
    // Try multiple paths to find the tax.json file
const possiblePaths = ['https://ituberus.github.io/OniStream/tax.json', '/productlib/tax.json', '/tax.json', '/api/tax.json', './tax.json', './productlib/tax.json'];
    let response: Response | null = null;
    
    for (const path of possiblePaths) {
      try {
        response = await fetch(path);
        if (response.ok) {
          console.log(`[Tax] Successfully loaded tax data from: ${path}`);
          break;
        }
      } catch (err) {
        console.log(`[Tax] Failed to load from ${path}, trying next...`);
        continue;
      }
    }
    
    if (!response || !response.ok) {
      throw new Error('All tax data paths failed');
    }
    
    const responseText = await response.text();
    
    // Check if response is HTML (404 page) instead of JSON
    if (responseText.trim().startsWith('<!DOCTYPE') || responseText.trim().startsWith('<html')) {
      console.error('[Tax] Received HTML instead of JSON, tax.json file not found');
      throw new Error('tax.json file not found - received HTML page');
    }
    
    taxData = JSON.parse(responseText);
    console.log('[Tax] Tax data loaded successfully');
    return taxData;
  } catch (error) {
    console.error('[Tax] Error loading tax data:', error);
    // Return comprehensive fallback tax data
    return {
      "US": { 
        "type": "sales_tax", 
        "currency": "USD", 
        "rate": 0, 
        "states": { 
          "AL": { "rate": 0.04, "type": "sales_tax" },
          "AK": { "rate": 0, "type": "sales_tax" },
          "AZ": { "rate": 0.056, "type": "sales_tax" },
          "AR": { "rate": 0.065, "type": "sales_tax" },
          "CA": { "rate": 0.0725, "type": "sales_tax" },
          "CO": { "rate": 0.029, "type": "sales_tax" },
          "CT": { "rate": 0.0635, "type": "sales_tax" },
          "DE": { "rate": 0, "type": "sales_tax" },
          "FL": { "rate": 0.06, "type": "sales_tax" },
          "GA": { "rate": 0.04, "type": "sales_tax" },
          "HI": { "rate": 0.04, "type": "sales_tax" },
          "ID": { "rate": 0.06, "type": "sales_tax" },
          "IL": { "rate": 0.0625, "type": "sales_tax" },
          "IN": { "rate": 0.07, "type": "sales_tax" },
          "IA": { "rate": 0.06, "type": "sales_tax" },
          "KS": { "rate": 0.065, "type": "sales_tax" },
          "KY": { "rate": 0.06, "type": "sales_tax" },
          "LA": { "rate": 0.0445, "type": "sales_tax" },
          "ME": { "rate": 0.055, "type": "sales_tax" },
          "MD": { "rate": 0.06, "type": "sales_tax" },
          "MA": { "rate": 0.0625, "type": "sales_tax" },
          "MI": { "rate": 0.06, "type": "sales_tax" },
          "MN": { "rate": 0.06875, "type": "sales_tax" },
          "MS": { "rate": 0.07, "type": "sales_tax" },
          "MO": { "rate": 0.04225, "type": "sales_tax" },
          "MT": { "rate": 0, "type": "sales_tax" },
          "NE": { "rate": 0.055, "type": "sales_tax" },
          "NV": { "rate": 0.0685, "type": "sales_tax" },
          "NH": { "rate": 0, "type": "sales_tax" },
          "NJ": { "rate": 0.06625, "type": "sales_tax" },
          "NM": { "rate": 0.05125, "type": "sales_tax" },
          "NY": { "rate": 0.08, "type": "sales_tax" },
          "NC": { "rate": 0.0475, "type": "sales_tax" },
          "ND": { "rate": 0.05, "type": "sales_tax" },
          "OH": { "rate": 0.0575, "type": "sales_tax" },
          "OK": { "rate": 0.045, "type": "sales_tax" },
          "OR": { "rate": 0, "type": "sales_tax" },
          "PA": { "rate": 0.06, "type": "sales_tax" },
          "RI": { "rate": 0.07, "type": "sales_tax" },
          "SC": { "rate": 0.06, "type": "sales_tax" },
          "SD": { "rate": 0.045, "type": "sales_tax" },
          "TN": { "rate": 0.07, "type": "sales_tax" },
          "TX": { "rate": 0.0625, "type": "sales_tax" },
          "UT": { "rate": 0.0485, "type": "sales_tax" },
          "VT": { "rate": 0.06, "type": "sales_tax" },
          "VA": { "rate": 0.053, "type": "sales_tax" },
          "WA": { "rate": 0.065, "type": "sales_tax" },
          "WV": { "rate": 0.06, "type": "sales_tax" },
          "WI": { "rate": 0.05, "type": "sales_tax" },
          "WY": { "rate": 0.04, "type": "sales_tax" }
        } 
      },
      "CA": { 
        "type": "gst", 
        "currency": "CAD", 
        "rate": 0.05,
        "states": {
          "AB": { "rate": 0, "type": "gst_only" }, // 5% GST only
          "BC": { "rate": 0.07, "type": "gst_pst" }, // 5% GST + 7% PST = 12%
          "MB": { "rate": 0.07, "type": "gst_pst" }, // 5% GST + 7% PST = 12%
          "NB": { "rate": 0.10, "type": "hst" }, // 10% HST (replaces GST+PST)
          "NL": { "rate": 0.10, "type": "hst" }, // 10% HST
          "NT": { "rate": 0, "type": "gst_only" }, // 5% GST only
          "NS": { "rate": 0.10, "type": "hst" }, // 10% HST
          "NU": { "rate": 0, "type": "gst_only" }, // 5% GST only
          "ON": { "rate": 0.08, "type": "hst" }, // 13% HST (5% GST + 8% provincial portion)
          "PE": { "rate": 0.10, "type": "hst" }, // 10% HST
          "QC": { "rate": 0.09975, "type": "gst_qst" }, // 5% GST + 9.975% QST = 14.975%
          "SK": { "rate": 0.06, "type": "gst_pst" }, // 5% GST + 6% PST = 11%
          "YT": { "rate": 0, "type": "gst_only" } // 5% GST only
        }
      },
      "GB": { "type": "vat", "currency": "GBP", "rate": 0.2 },
      "DE": { "type": "vat", "currency": "EUR", "rate": 0.19 },
      "FR": { "type": "vat", "currency": "EUR", "rate": 0.2 },
      "AU": { "type": "gst", "currency": "AUD", "rate": 0.1 },
      "NZ": { "type": "gst", "currency": "NZD", "rate": 0.15 },
      "NG": { "type": "vat", "currency": "NGN", "rate": 0.075 },
      "BR": { "type": "vat", "currency": "BRL", "rate": 0.17 },
      "IN": { "type": "gst", "currency": "INR", "rate": 0.18 }
    };
  }
};

/**
 * Get VAT rate for a specific country and optional state
 * Handles complex tax structures like Canada's GST + provincial tax
 */
export const getVATRate = async (countryCode: string, stateCode?: string): Promise<number> => {
  try {
    console.log(`[Tax] Getting VAT rate for country: ${countryCode}, state: ${stateCode}`);
    const data = await loadTaxData();
    
    if (!data[countryCode]) {
      console.warn(`[Tax] No tax data found for country: ${countryCode}`);
      return 0;
    }

    const countryTax = data[countryCode];
    
    // For countries with state-specific rates (like US, CA)
    if (stateCode && countryTax.states && countryTax.states[stateCode]) {
      const stateTax = countryTax.states[stateCode];
      let totalRate = 0;
      
      // Handle different tax systems
      if (countryCode === 'CA') {
        // Canadian tax system
        if (stateTax.type === 'hst') {
          // HST replaces both GST and provincial tax
          totalRate = stateTax.rate;
        } else if (stateTax.type === 'gst_pst' || stateTax.type === 'gst_qst') {
          // GST + provincial tax (PST/QST)
          totalRate = countryTax.rate + stateTax.rate; // Federal GST + Provincial tax
        } else if (stateTax.type === 'gst_only') {
          // GST only provinces
          totalRate = countryTax.rate; // Just federal GST
        } else {
          // Fallback
          totalRate = countryTax.rate + stateTax.rate;
        }
      } else {
        // For other countries (like US), just use state rate
        totalRate = stateTax.rate;
      }
      
      console.log(`[Tax] Using state rate for ${countryCode}-${stateCode}: ${totalRate} (type: ${stateTax.type})`);
      return totalRate;
    }

    // Return country-level rate (never use 'before' historical rates)
    const countryRate = countryTax.rate || 0;
    console.log(`[Tax] Using country rate for ${countryCode}: ${countryRate}`);
    return countryRate;
  } catch (error) {
    console.error('[Tax] Error getting VAT rate:', error);
    return 0;
  }
};

/**
 * Calculate VAT amount based on price, country, and optional state
 */
export const calculateVATAmount = async (
  price: number, 
  countryCode: string, 
  stateCode?: string
): Promise<number> => {
  console.log(`[Tax] Calculating VAT for price: ${price}, country: ${countryCode}, state: ${stateCode}`);
  const vatRate = await getVATRate(countryCode, stateCode);
  const vatAmount = parseFloat((price * vatRate).toFixed(2));
  console.log(`[Tax] VAT calculated: ${vatAmount} (rate: ${vatRate})`);
  return vatAmount;
};

/**
 * Get tax information for a country and state
 */
export const getTaxInfo = async (countryCode: string, stateCode?: string): Promise<{
  rate: number;
  type: string;
  currency: string;
  breakdown?: {
    federal?: { rate: number; type: string };
    provincial?: { rate: number; type: string };
  };
}> => {
  try {
    console.log(`[Tax] Getting tax info for country: ${countryCode}, state: ${stateCode}`);
    const data = await loadTaxData();
    
    if (!data[countryCode]) {
      console.warn(`[Tax] No tax info found for country: ${countryCode}`);
      return { rate: 0, type: 'none', currency: 'USD' };
    }

    const countryTax = data[countryCode];
    
    // For countries with state-specific rates
    if (stateCode && countryTax.states && countryTax.states[stateCode]) {
      const stateTax = countryTax.states[stateCode];
      let totalRate = 0;
      let taxType = stateTax.type;
      let breakdown: any = undefined;
      
      // Handle different tax systems
      if (countryCode === 'CA') {
        // Canadian tax system
        if (stateTax.type === 'hst') {
          // HST replaces both GST and provincial tax
          totalRate = stateTax.rate;
          taxType = 'HST';
        } else if (stateTax.type === 'gst_pst') {
          // GST + PST
          totalRate = countryTax.rate + stateTax.rate;
          taxType = 'GST + PST';
          breakdown = {
            federal: { rate: countryTax.rate, type: 'GST' },
            provincial: { rate: stateTax.rate, type: 'PST' }
          };
        } else if (stateTax.type === 'gst_qst') {
          // GST + QST (Quebec)
          totalRate = countryTax.rate + stateTax.rate;
          taxType = 'GST + QST';
          breakdown = {
            federal: { rate: countryTax.rate, type: 'GST' },
            provincial: { rate: stateTax.rate, type: 'QST' }
          };
        } else if (stateTax.type === 'gst_only') {
          // GST only provinces
          totalRate = countryTax.rate;
          taxType = 'GST';
        } else {
          // Fallback
          totalRate = countryTax.rate + stateTax.rate;
          taxType = stateTax.type;
        }
      } else {
        // For other countries (like US), just use state rate
        totalRate = stateTax.rate;
        taxType = stateTax.type;
      }
      
      const result = {
        rate: totalRate,
        type: taxType,
        currency: countryTax.currency,
        breakdown
      };
      console.log(`[Tax] State tax info for ${countryCode}-${stateCode}:`, result);
      return result;
    }

    // Return country-level info
    const result = {
      rate: countryTax.rate || 0,
      type: countryTax.type || 'none',
      currency: countryTax.currency || 'USD'
    };
    console.log(`[Tax] Country tax info for ${countryCode}:`, result);
    return result;
  } catch (error) {
    console.error('[Tax] Error getting tax info:', error);
    return { rate: 0, type: 'none', currency: 'USD' };
  }
};

types.ts
// productlib/types.ts
export interface IImage {
    url: string;
    isMain: boolean;
  }
  
  export interface IShippingMethod {
    name: string;
    price: number; // 0 means free shipping
    minDays: number;
    maxDays: number;
  }
  
  export interface IVariant {
    name: string;
    values: string[];
    stock: number;
  }
  
  export interface IVariantSelection {
    name: string;
    value: string;
  }
  
  export interface IDigitalOptions {
    fileUrl?: string;
    fileUpload?: string;
    recurring?: {
      interval: 'monthly' | 'yearly';
      trialDays?: number;
      hasTrial: boolean;
    };
  }
  
  export interface IPhysicalOptions {
    weight?: number;  // in kg
    dimensions?: {
      length: number;
      width: number;
      height: number;
    };
    shippingClass?: string;
    stock?: number;
    shippingMethods?: IShippingMethod[];
  }
  
  export interface IProduct {
    _id: string;
    merchantId?: string;
    title: string;
    shortDescription: string;
    longDescription: string;
    description?: string;
    slug: string;
    price: number;
    defaultCurrency: string;
    autoLocalPrice: boolean;
    productSource?: 'shopify' | 'woocommerce' | 'wordpress' | 'customapi' | 'hosted' | 'others';
    vatEnabled: boolean;
    type: 'digital' | 'physical';
    sku?: string;
    barcode?: string;
    digital?: IDigitalOptions;
    physical?: IPhysicalOptions;
    variants?: IVariant[];
    images: IImage[];
    status?: 'active' | 'deactivated' | 'deleted';
    quantityEnabled?: boolean; // New field to enable/disable quantity selection
    // Add these new fields for local currency handling
    localPrice?: number;
    localCurrency?: string;
  }
  
  export interface IBillingInfo {
    email: string;
    phone?: string;
    name: string;
    address: string;
    city: string;
    state: string;
    postalCode: string;
    country: string;
  }
  
export interface ITransactionItem {
  productId: string;
  productSlug: string;
  productName: string;
  productType: 'digital' | 'physical';
  productOwnerId: string;
  quantity: number;
  unitPrice: number; // Price of ONE unit in the sale currency
  totalPrice: number;  // << CHANGED from subtotal: This should be unitPrice * quantity for THIS item line
  currency: string;   // << CHANGED from productCurrency: Currency for THIS item line
  vatEnabled: boolean;
  vatAmount?: number; // VAT amount for THIS item line
  variants?: IVariantSelection[];
}
  
  // Define the transaction types and statuses
  export type TransactionType = 'sale' | 'refund' | 'payout_debit' | 'adjustment' | 'fee';
  export type TransactionStatus = 'successful' | 'pending' | 'canceled' | 'failed' | 'refunded' | 'others';

  // Simplified transaction interface for API calls - matches backend expectations
  export interface ITransaction {
    items: ITransactionItem[];
    productSource: 'hosted' | 'shopify' | 'woocommerce' | 'wordpress' | 'customapi' | 'others';
    saleCurrency: string;
    subtotal: number;
    shippingFee?: number;
    total: number;
    paymentMethod: 'card' | 'pix' | 'paypal' | 'wallet' | 'other';
    buyerEmail: string;
    buyerPhone?: string;
    billingName: string;
    billingAddress: string;
    billingCity: string;
    billingState: string;
    billingPostalCode: string;
    billingCountry: string;
    status: TransactionStatus;
    ipAddress?: string;
    deviceInfo?: string;
    browserInfo?: string;
    metadata?: Record<string, any>;
    
    // Additional fields for Stripe integration
    useStripe?: boolean;
    paymentIntentId?: string;
    
    // Legacy fields for compatibility
    type?: TransactionType;
    originAmount?: number;
    originCurrency?: string;
  }
  
  export interface ICurrency {
    code: string;
    symbol: string;
    name: string;
    countries: string[];
    pixSupported: boolean;
  }
  
  export interface IFormData {
    quantity: number;
    variantSelections: IVariantSelection[];
    billingInfo: IBillingInfo;
    paymentMethod: 'card' | 'pix' | 'paypal' | 'wallet' | 'other';
  }
  
  export interface IApiResponse<T> {
    success: boolean;
    message: string;
    data?: T;
    errors?: any;
  }

utils.ts
// productlib/utils.ts
import { 
    IProduct, 
    IVariant, 
    IVariantSelection, 
    IBillingInfo, 
    ITransactionItem 
  } from './types';
  import { calculateVATAmount } from './tax';
  
  /**
   * Check if a product is in stock and available for purchase
   */
  export const isProductInStock = (
    product: IProduct, 
    variantSelections: IVariantSelection[],
    requestedQuantity: number = 1
  ): boolean => {
    // Digital products are always in stock
    if (product.type === 'digital') {
      return true;
    }
  
    // If variants exist, check if selected variants are in stock
    if (product.variants && product.variants.length > 0) {
      // If no variant is selected but variants exist, product is not ready for purchase
      if (variantSelections.length === 0) {
        return false;
      }
  
      // Check if all required variants are selected
      for (const variant of product.variants) {
        const selection = variantSelections.find(s => s.name === variant.name);
        
        // If a variant type doesn't have a selection, product is not ready
        if (!selection || !selection.value) {
          return false;
        }
        
        // Check if the selected variant value is valid
        const valueIndex = variant.values.indexOf(selection.value);
        if (valueIndex === -1) {
          return false;
        }
        
        // Only check stock if stock management is enabled for this variant (variant.stock is defined)
        if (variant.stock !== undefined) {
          if (variant.stock < requestedQuantity) {
            return false;
          }
        }
        // If variant.stock is undefined, it means unlimited stock, so no stock check needed
      }
      
      return true;
    }
  
    // If no variants, check product stock only if stock management is enabled
    if (product.physical && product.physical.stock !== undefined) {
      return product.physical.stock >= requestedQuantity;
    }
  
    // If no stock tracking (stock is undefined), assume it's available (unlimited stock)
    return true;
  };

  /**
   * Get maximum available quantity for a product
   */
  export const getMaxAvailableQuantity = (
    product: IProduct,
    variantSelections: IVariantSelection[]
  ): number => {
    // Digital products have no quantity limit
    if (product.type === 'digital') {
      return 999;
    }

    // If variants exist
    if (product.variants && product.variants.length > 0) {
      // Check if all variants are selected
      const allVariantsSelected = variantSelections.every(selection => selection.value);
      if (!allVariantsSelected) {
        return 1; // Can't determine stock until all variants are selected
      }

      // Get minimum stock across selected variants (only for variants with stock management enabled)
      let minStock = 999;
      let hasStockManagement = false;
      
      for (const variant of product.variants) {
        const selection = variantSelections.find(s => s.name === variant.name);
        // Only check stock if stock management is enabled for this variant (variant.stock is defined)
        if (selection && variant.stock !== undefined) {
          hasStockManagement = true;
          minStock = Math.min(minStock, variant.stock);
        }
      }

      // If no variant has stock management enabled, return unlimited (999)
      if (!hasStockManagement) {
        return 999;
      }

      return Math.max(0, minStock);
    }

    // No variants - check product stock only if stock management is enabled
    if (product.physical?.stock !== undefined) {
      return Math.max(0, product.physical.stock);
    }

    // No stock management enabled = unlimited stock
    return 999;
  };

  /**
   * Get stock status text for display
   */
  export const getStockStatusText = (
    product: IProduct,
    variantSelections: IVariantSelection[]
  ): string => {
    if (product.type === 'digital') {
      return '';
    }

    const maxQuantity = getMaxAvailableQuantity(product, variantSelections);

    // If variants exist but not all are selected
    if (product.variants && product.variants.length > 0) {
      const allVariantsSelected = variantSelections.every(selection => selection.value);
      if (!allVariantsSelected) {
        return 'Select all options to see availability';
      }
    }

    // Check if any variant or product has stock management enabled
    let hasStockManagement = false;
    if (product.variants && product.variants.length > 0) {
      hasStockManagement = product.variants.some(variant => variant.stock !== undefined);
    } else {
      hasStockManagement = product.physical?.stock !== undefined;
    }

    // If no stock management is enabled, don't show any stock info (unlimited stock)
    if (!hasStockManagement) {
      return '';
    }

    if (maxQuantity === 0) {
      return 'Out of stock';
    } else if (maxQuantity < 10) {
      return `Only ${maxQuantity} left in stock`;
    } else {
      return `${maxQuantity} available`;
    }
  };
  
  /**
   * Calculate VAT amount based on price - Updated to use tax data
   */
  export const calculateVAT = async (
    price: number, 
    countryCode?: string, 
    stateCode?: string
  ): Promise<number> => {
    if (!countryCode) {
      return 0;
    }
    
    return await calculateVATAmount(price, countryCode, stateCode);
  };
  
  /**
   * Calculate shipping fee
   */
  export const calculateShippingFee = (
    product: IProduct, 
    shippingMethodName?: string
  ): number => {
    if (product.type === 'digital') {
      return 0; // No shipping for digital products
    }
    
    if (!product.physical || !product.physical.shippingMethods || product.physical.shippingMethods.length === 0) {
      return 0; // No shipping methods defined
    }
    
    // If specific shipping method is selected
    if (shippingMethodName) {
      const method = product.physical.shippingMethods.find(m => m.name === shippingMethodName);
      return method ? method.price : 0;
    }
    
    // Default to first shipping method
    return product.physical.shippingMethods[0].price;
  };
  
  /**
   * Calculate total price including quantity, VAT, and shipping - Updated to use tax data
   */
  export const calculateTotalPrice = async (
    product: IProduct, 
    quantity: number, 
    shippingMethodName?: string,
    countryCode?: string,
    stateCode?: string
  ): Promise<{ subtotal: number; vat: number; shipping: number; total: number }> => {
    const unitPrice = (product as any).localPrice || product.price;
    const subtotal = unitPrice * quantity;
    const vat = await calculateVAT(subtotal, countryCode, stateCode);
    const shipping = calculateShippingFee(product, shippingMethodName);
    
    return {
      subtotal,
      vat,
      shipping,
      total: subtotal + vat + shipping,
    };
  };

  /**
   * Synchronous version of calculateTotalPrice for cases where VAT is already calculated
   */
  export const calculateTotalPriceSync = (
    product: IProduct, 
    quantity: number, 
    shippingMethodName?: string,
    preCalculatedVAT?: number
  ): { subtotal: number; vat: number; shipping: number; total: number } => {
    const unitPrice = (product as any).localPrice || product.price;
    const subtotal = unitPrice * quantity;
    const vat = preCalculatedVAT || 0;
    const shipping = calculateShippingFee(product, shippingMethodName);
    
    return {
      subtotal,
      vat,
      shipping,
      total: subtotal + vat + shipping,
    };
  };
  
  /**
   * Validate billing information
   */
  export const validateBillingInfo = (billingInfo: IBillingInfo): { valid: boolean; errors: Record<string, string> } => {
    const errors: Record<string, string> = {};
    
    // Basic email validation
    if (!billingInfo.email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(billingInfo.email)) {
      errors.email = 'Please enter a valid email address';
    }
    
    // Required fields
    if (!billingInfo.name) errors.name = 'Name is required';
    if (!billingInfo.address) errors.address = 'Address is required';
    if (!billingInfo.city) errors.city = 'City is required';
    if (!billingInfo.state) errors.state = 'State is required';
    if (!billingInfo.postalCode) errors.postalCode = 'Postal code is required';
    if (!billingInfo.country) errors.country = 'Country is required';
    
    // Phone validation (simplified)
    if (billingInfo.phone && !/^[+]?[\d\s()-]{8,20}$/.test(billingInfo.phone)) {
      errors.phone = 'Please enter a valid phone number';
    }
    
    return {
      valid: Object.keys(errors).length === 0,
      errors,
    };
  };
  
  /**
   * Prepare transaction item from product and selections
   */
  export const prepareTransactionItem = (
    product: IProduct,
    quantity: number,
    variantSelections: IVariantSelection[],
    subtotal: number,
    vatAmount: number
  ): ITransactionItem => {
    const unitPrice = (product as any).localPrice || product.price;
    const displayCurrency = (product as any).localCurrency || product.defaultCurrency;
    
    return {
      productId: product._id,
      productSlug: product.slug,
      productName: product.title,
      productType: product.type,
      productOwnerId: product.merchantId || '',
      quantity,
      unitPrice: unitPrice,
      totalPrice: subtotal,
      currency: displayCurrency,
      vatEnabled: true, // Always enabled now
      vatAmount: vatAmount,
      variants: variantSelections.length > 0 ? variantSelections : undefined,
    };
  };
  
  /**
   * Get main image URL from product
   */
  export const getMainImageUrl = (product: IProduct): string => {
    if (!product.images || product.images.length === 0) {
      return '';
    }
    const mainImage = product.images.find(img => img.isMain);
    return mainImage ? mainImage.url : (product.images[0]?.url || '');
  };
  
  /**
   * Format date in a readable format
   */
  export const formatDate = (date: Date): string => {
    return new Intl.DateTimeFormat('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: 'numeric',
      minute: 'numeric',
      hour12: true
    }).format(date);
  };
  
  /**
   * Generate a random transaction ID (matching original pattern)
   */
  export const generateTransactionId = (): string => {
    return `TX_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`.toUpperCase();
  };

  /**
   * Check if quantity selection should be enabled for a product
   */
  export const isQuantitySelectionEnabled = (product: IProduct): boolean => {
    // Default to true if quantityEnabled is not set (backward compatibility)
    return product.quantityEnabled !== false;
  };

  /**
   * Get product display info for different product types
   */
  export const getProductDisplayInfo = (product: IProduct): {
    recurringText: string;
    trialText: string;
    stockText: string;
    hasImages: boolean;
    mainImageUrl: string;
  } => {
    let recurringText = '';
    let trialText = '';
    
    // Handle recurring subscription text for digital products
    if (product.type === 'digital' && product.digital?.recurring) {
      const { interval, hasTrial, trialDays } = product.digital.recurring;
      
      if (interval === 'monthly') {
        recurringText = '/month';
      } else if (interval === 'yearly') {
        recurringText = '/year';
      }

      if (hasTrial) {
        if (trialDays && trialDays > 0) {
          trialText = `${trialDays}-day free trial`;
        } else {
          trialText = 'Free trial';
        }
      }
    }

    const hasImages = product.images && product.images.length > 0;
    const mainImageUrl = getMainImageUrl(product);
    const stockText = getStockStatusText(product, []); // Empty selections for initial display

    return {
      recurringText,
      trialText,
      stockText,
      hasImages,
      mainImageUrl,
    };
  };



